{-
Name: Sophia Trump
File: Asst2.hs
Desc: CS245, Assignment 2
-}

module Asst2 where

-- Part I: Programming with Lists

findWithDefault :: Eq a => a -> [(a,b)] -> b -> b
findWithDefault toFind [] failReturn = failReturn
findWithDefault toFind ((x,y):xs) failReturn
 | toFind == x = y
 | otherwise = findWithDefault toFind xs failReturn


find :: Eq a => a -> [(a,b)] -> Maybe b
find toFind [] = Nothing
find toFind ((x,y):xs)
 | toFind == x = Just y
 | otherwise = find toFind xs


index :: Integer -> [a] -> Maybe a
index n [] = Nothing
index n (x:xs)
 | n == 0 = Just x
 | otherwise = index (n - 1) xs


tails :: [a] -> [[a]]
tails [] = [[]]
tails (x:xs) = [x:xs] ++ tails(xs)


factorsBelow :: Integer -> Integer -> [Integer]
factorsBelow n d
 | d <= 0 = []
 | n `mod` d == 0 = d : factorsBelow n (d - 1)
 | otherwise = factorsBelow n (d - 1)


factors :: Integer -> [Integer]
factors n = factorsBelow n n


digitsR :: Integer -> [Integer]
digitsR n
 | n <= 0 = []
 | otherwise = n `mod` 10 : digitsR(n `div` 10)


digits :: Integer -> [Integer]
digits n = reverse (digitsR n)


undigitsR :: [Integer] -> Integer
undigitsR [] = 0
undigitsR (x:xs) = ((undigitsR xs) * 10) + x


undigits :: [Integer] -> Integer
undigits [] = 0
undigits (x:xs) = undigitsR (reverse (x:xs))


-- Part II: Sorting
insert :: Ord a => a -> [a] -> [a] -- assumes the list is in non-decreasing order
insert n [] = [n]
insert n (x:xs)
 | n <= x = n : x : xs
 | otherwise = x : insert n (xs)


insertionSort :: Ord a => [a] -> [a] -- puts the list in non-decreasing order
insertionSort [] = []
insertionSort (x:xs) = insert x unSorted
  where
    unSorted = insertionSort xs  -- call insertionSort on the rest of the list


select :: Ord a => a -> [a] -> (a, [a])
select n [] = (n, [])
select n (x:xs)
 | mini < n = (mini, n : (orderList mini (x:xs)))
 | otherwise = (mini, orderList mini (x:xs))
  where
    mini = findMinElement n (x:xs)


findMinElement :: Ord a => a -> [a] -> a
findMinElement n [] = n
findMinElement n (x:xs)
 | x < n = findMinElement x xs
 | otherwise = findMinElement n xs


orderList :: Ord a => a -> [a] -> [a]
orderList n [] = []
orderList n (x:xs)
 | n == x = xs                               -- found the min element
 | otherwise = [x] ++ orderList n xs


selectionSort :: Ord a => [a] -> [a]
selectionSort [] = []
selectionSort (x : xs) = [smallest] ++ selectionSort(leftOver)
  where
    (smallest, leftOver) = select x (xs)


merge :: Ord a => [a] -> [a] -> [a]
merge [] [] = []
merge (x:xs) [] = (x:xs)
merge [] (y:ys) = (y:ys)
merge (x:xs) (y:ys)
 | x < y = x : merge xs (y:ys) -- add x
 | x > y = y : merge (x:xs) ys -- add y
 | x == y = x : y : merge xs ys -- add x and y


-- SOURCE : from textbook Hu page 38
split :: [a] -> ([a],[a])
split xs = (take ((length xs) `div` 2) xs, drop ((length xs) `div` 2) xs)


mergeSort :: Ord a => [a] -> [a]
mergeSort [] = []
mergeSort n
 | (length n) > 1 = merge (mergeSort splitLeft) (mergeSort splitRight) -- split until you get down to one
 | otherwise = n  -- the length of n is 1, so return n
 where
   (splitLeft, splitRight) = split n


quickSort :: Ord a => [a] -> [a]
quickSort [] = []
quickSort (x:xs) = quickSort(smaller) ++ [x] ++ quickSort(larger)
  where
    (smaller, larger) = subSortQuick x xs


subSortQuick :: Ord a => a -> [a] -> ([a],[a])
subSortQuick _ [] = ([],[])
subSortQuick n (x:xs)
 | x < n =  (x : leftList, rightList)-- put left of the pivot
 | otherwise =  (leftList, x: rightList) -- put right of the pivot
  where
    (leftList,rightList) = subSortQuick n xs -- recurse until entire list is divided by sublist
